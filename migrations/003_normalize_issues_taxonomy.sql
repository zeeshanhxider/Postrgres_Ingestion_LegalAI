-- Migration 003: Normalize issues_decisions with taxonomy table
-- This creates a hierarchical taxonomy for issue categories/subcategories
-- Following the "snowflake" database design pattern

-- ============================================
-- STEP 1: Create the taxonomy table
-- ============================================
-- This is a self-referencing hierarchy table where:
-- Level 0: Root (e.g., "Family Law")
-- Level 1: Category (e.g., "Property Division / Debt Allocation")
-- Level 2: Subcategory (e.g., "Valuation of assets")

CREATE TABLE IF NOT EXISTS issue_taxonomy (
    taxonomy_id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    parent_id BIGINT REFERENCES issue_taxonomy(taxonomy_id) ON DELETE SET NULL,
    name CITEXT NOT NULL,
    level INTEGER NOT NULL DEFAULT 0,  -- 0=root, 1=category, 2=subcategory
    description TEXT,
    display_order INTEGER DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    
    -- Ensure unique names at same level under same parent
    UNIQUE(parent_id, name)
);

-- Index for fast lookups
CREATE INDEX IF NOT EXISTS idx_issue_taxonomy_parent ON issue_taxonomy(parent_id);
CREATE INDEX IF NOT EXISTS idx_issue_taxonomy_level ON issue_taxonomy(level);
CREATE INDEX IF NOT EXISTS idx_issue_taxonomy_name ON issue_taxonomy(name);

-- Trigger for updated_at
CREATE TRIGGER trg_issue_taxonomy_updated 
    BEFORE UPDATE ON issue_taxonomy 
    FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- ============================================
-- STEP 2: Insert the root node
-- ============================================
INSERT INTO issue_taxonomy (name, level, description, display_order)
VALUES ('Family Law', 0, 'Root category for all family law issues in Washington State divorce cases', 1)
ON CONFLICT DO NOTHING;

-- ============================================
-- STEP 3: Insert categories (Level 1)
-- ============================================
-- Get the root ID and insert categories as children
DO $$
DECLARE
    root_id BIGINT;
BEGIN
    SELECT taxonomy_id INTO root_id FROM issue_taxonomy WHERE level = 0 AND name = 'Family Law';
    
    -- Insert all 9 categories
    INSERT INTO issue_taxonomy (parent_id, name, level, description, display_order)
    VALUES 
        (root_id, 'Property Division / Debt Allocation', 1, 'Division of marital property and allocation of debts', 1),
        (root_id, 'Spousal Support / Maintenance', 1, 'Alimony and spousal maintenance issues', 2),
        (root_id, 'Child Support', 1, 'Child support calculation, modification, and enforcement', 3),
        (root_id, 'Parenting Plan / Custody / Visitation', 1, 'Custody, residential schedules, and parenting time', 4),
        (root_id, 'Attorney Fees & Costs', 1, 'Award of attorney fees and litigation costs', 5),
        (root_id, 'Procedural & Evidentiary Issues', 1, 'Due process, evidence rules, and procedural matters', 6),
        (root_id, 'Enforcement & Contempt Orders', 1, 'Enforcement of court orders and contempt proceedings', 7),
        (root_id, 'Jurisdiction & Venue', 1, 'Subject matter and personal jurisdiction issues', 8),
        (root_id, 'Miscellaneous / Unclassified', 1, 'Other issues not fitting standard categories', 9)
    ON CONFLICT (parent_id, name) DO NOTHING;
END $$;

-- ============================================
-- STEP 4: Insert subcategories (Level 2)
-- ============================================
-- Insert all unique subcategories from issues_decisions as children of their categories
DO $$
DECLARE
    cat_rec RECORD;
    cat_id BIGINT;
    subcat_rec RECORD;
BEGIN
    -- Loop through each category
    FOR cat_rec IN SELECT DISTINCT category FROM issues_decisions ORDER BY category
    LOOP
        -- Find the taxonomy_id for this category
        SELECT taxonomy_id INTO cat_id 
        FROM issue_taxonomy 
        WHERE name = cat_rec.category AND level = 1;
        
        IF cat_id IS NOT NULL THEN
            -- Insert all subcategories for this category
            FOR subcat_rec IN 
                SELECT DISTINCT subcategory, COUNT(*) as cnt 
                FROM issues_decisions 
                WHERE category = cat_rec.category 
                GROUP BY subcategory 
                ORDER BY COUNT(*) DESC, subcategory
            LOOP
                INSERT INTO issue_taxonomy (parent_id, name, level, description, display_order)
                VALUES (cat_id, subcat_rec.subcategory, 2, NULL, 0)
                ON CONFLICT (parent_id, name) DO NOTHING;
            END LOOP;
        END IF;
    END LOOP;
END $$;

-- ============================================
-- STEP 5: Add taxonomy_id to issues_decisions
-- ============================================
ALTER TABLE issues_decisions 
ADD COLUMN IF NOT EXISTS taxonomy_id BIGINT REFERENCES issue_taxonomy(taxonomy_id) ON DELETE SET NULL;

CREATE INDEX IF NOT EXISTS idx_issues_decisions_taxonomy ON issues_decisions(taxonomy_id);

-- ============================================
-- STEP 6: Populate taxonomy_id based on existing category/subcategory
-- ============================================
UPDATE issues_decisions id
SET taxonomy_id = t.taxonomy_id
FROM issue_taxonomy t
WHERE t.name = id.subcategory 
  AND t.level = 2
  AND t.parent_id IN (
      SELECT taxonomy_id FROM issue_taxonomy WHERE name = id.category AND level = 1
  );

-- ============================================
-- STEP 7: Verify migration
-- ============================================
-- This should show all taxonomy entries
-- SELECT * FROM issue_taxonomy ORDER BY level, parent_id, display_order, name;

-- This should show how many issues are linked
-- SELECT COUNT(*) as linked, COUNT(taxonomy_id) as with_taxonomy FROM issues_decisions;

-- ============================================
-- OPTIONAL: Drop old columns after verification
-- ============================================
-- Once verified, you can optionally drop the old text columns:
-- ALTER TABLE issues_decisions DROP COLUMN category;
-- ALTER TABLE issues_decisions DROP COLUMN subcategory;
-- 
-- But keep them for now as a backup during transition
