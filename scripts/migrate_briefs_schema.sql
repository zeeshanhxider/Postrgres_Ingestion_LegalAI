-- Migration Script: Add Briefs Schema to Existing Database
-- Version: 2.1
-- Date: November 21, 2025
-- Description: Adds complete briefs schema with all critical improvements
--              - Case ID normalization (folder + filename)
--              - Brief chaining (conversation reconstruction)
--              - Argument hierarchy (nested structure)
--              - Table of Authorities priority
--              - Multi-strategy linking

-- ============================================================================
-- SAFETY CHECKS
-- ============================================================================

DO $$ 
BEGIN
    -- Check if briefs table already exists
    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'briefs') THEN
        RAISE NOTICE 'WARNING: briefs table already exists. Migration may have already been run.';
    END IF;
END $$;

-- ============================================================================
-- NORMALIZATION FUNCTION (Must be created first)
-- ============================================================================

CREATE OR REPLACE FUNCTION normalize_case_file_id(case_file_id TEXT)
RETURNS TEXT AS $$
BEGIN
    -- Remove all non-digit characters to create normalized ID
    -- Examples: "69423-5" -> "694235", "83895-4-I" -> "838954"
    RETURN regexp_replace(case_file_id, '[^0-9]', '', 'g');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

COMMENT ON FUNCTION normalize_case_file_id IS 'Normalizes case_file_id by removing all non-digit characters for fuzzy matching';

-- ============================================================================
-- TABLE 1: briefs (Main brief metadata)
-- ============================================================================

CREATE TABLE IF NOT EXISTS briefs (
    brief_id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    case_id            BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,
    case_file_id       CITEXT NOT NULL,
    case_file_id_normalized CITEXT NOT NULL,
    
    -- Brief chaining (conversation of law)
    responds_to_brief_id BIGINT REFERENCES briefs(brief_id) ON DELETE SET NULL,
    brief_sequence       INTEGER,
    
    -- Brief identification
    brief_sequence_id  CITEXT,
    brief_type         CITEXT NOT NULL,
    filing_party       CITEXT NOT NULL,
    
    -- Filename case ID extraction (multi-strategy linking)
    filename_case_id   CITEXT,
    filename_case_id_normalized CITEXT,
    
    -- Brief metadata
    title              TEXT,
    filing_date        DATE,
    page_count         INTEGER,
    word_count         INTEGER,
    
    -- Content and embedding
    summary            TEXT,
    full_text          TEXT,
    full_embedding     VECTOR(1024),
    
    -- Source tracking
    source_file        CITEXT NOT NULL,
    source_file_path   TEXT NOT NULL,
    year               INTEGER,
    
    -- Processing metadata
    processing_status  CITEXT DEFAULT 'pending',
    extraction_timestamp TIMESTAMP,
    
    -- Timestamps
    created_at         TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at         TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE briefs IS 'Legal briefs with multi-strategy case linking and conversation tracking';
COMMENT ON COLUMN briefs.case_file_id_normalized IS 'Normalized folder case_file_id for fuzzy matching';
COMMENT ON COLUMN briefs.filename_case_id IS 'Case ID extracted from filename suffix (e.g., "934" from "762508_appellants_reply_brief_934.pdf")';
COMMENT ON COLUMN briefs.responds_to_brief_id IS 'Self-referential FK for brief chaining (Opening -> Response -> Reply)';

-- Indexes
CREATE INDEX idx_briefs_case_id ON briefs(case_id);
CREATE INDEX idx_briefs_case_file_id ON briefs(case_file_id);
CREATE INDEX idx_briefs_case_file_id_normalized ON briefs(case_file_id_normalized);
CREATE INDEX idx_briefs_filename_case_id ON briefs(filename_case_id);
CREATE INDEX idx_briefs_filename_case_id_normalized ON briefs(filename_case_id_normalized);
CREATE INDEX idx_briefs_responds_to ON briefs(responds_to_brief_id);
CREATE INDEX idx_briefs_sequence ON briefs(case_file_id_normalized, brief_sequence);
CREATE INDEX idx_briefs_brief_type ON briefs(brief_type);
CREATE INDEX idx_briefs_filing_party ON briefs(filing_party);
CREATE INDEX idx_briefs_year ON briefs(year);
CREATE INDEX idx_briefs_sequence_id ON briefs(brief_sequence_id);
CREATE INDEX idx_briefs_status ON briefs(processing_status);

-- Vector similarity search
CREATE INDEX idx_briefs_embedding ON briefs 
    USING ivfflat (full_embedding vector_cosine_ops) 
    WITH (lists = 100);

-- Full-text search
CREATE INDEX idx_briefs_title_gin ON briefs 
    USING gin(to_tsvector('english', COALESCE(title, '')));
CREATE INDEX idx_briefs_summary_gin ON briefs 
    USING gin(to_tsvector('english', COALESCE(summary, '')));

-- Updated timestamp trigger
CREATE TRIGGER trg_briefs_updated BEFORE UPDATE ON briefs
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- ============================================================================
-- TABLE 2: brief_chunks (Text chunks with embeddings for RAG)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_chunks (
    chunk_id       UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    brief_id       BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    case_id        BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,
    
    -- Chunk content
    chunk_order    INTEGER NOT NULL,
    text           TEXT NOT NULL,
    section        CITEXT,
    
    -- Chunk metadata
    word_count     INTEGER,
    char_count     INTEGER,
    
    -- Embedding
    embedding      VECTOR(1024),
    
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE brief_chunks IS 'Text chunks from briefs with section awareness for RAG';
COMMENT ON COLUMN brief_chunks.section IS 'Brief section (e.g., ARGUMENT, STATEMENT_OF_FACTS, TABLE_OF_AUTHORITIES)';

-- Indexes
CREATE INDEX idx_brief_chunks_brief_id ON brief_chunks(brief_id);
CREATE INDEX idx_brief_chunks_case_id ON brief_chunks(case_id);
CREATE INDEX idx_brief_chunks_order ON brief_chunks(brief_id, chunk_order);

-- Vector similarity search
CREATE INDEX idx_brief_chunks_embedding ON brief_chunks 
    USING ivfflat (embedding vector_cosine_ops) 
    WITH (lists = 100);

-- Full-text search
CREATE INDEX idx_brief_chunks_text_gin ON brief_chunks 
    USING gin(to_tsvector('english', text));

-- ============================================================================
-- TABLE 3: brief_arguments (Hierarchical argument structure)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_arguments (
    brief_argument_id  BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    brief_id           BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    case_id            BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,
    issue_id           BIGINT REFERENCES issues_decisions(issue_id) ON DELETE SET NULL,
    
    -- Argument hierarchy (CRITICAL)
    parent_argument_id BIGINT REFERENCES brief_arguments(brief_argument_id) ON DELETE CASCADE,
    hierarchy_level    INTEGER NOT NULL DEFAULT 1,
    hierarchy_path     TEXT,
    sort_order         INTEGER,
    
    -- Argument content
    argument_heading   TEXT,
    argument_text      TEXT NOT NULL,
    
    -- Argument metadata
    argument_number    INTEGER,
    page_number        INTEGER,
    
    -- AI extraction
    related_issues     TEXT[],
    cited_cases        TEXT[],
    cited_statutes     TEXT[],
    
    created_at         TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at         TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE brief_arguments IS 'Hierarchical arguments from briefs (e.g., III -> A -> 1)';
COMMENT ON COLUMN brief_arguments.parent_argument_id IS 'Self-referential FK for nested argument structure';
COMMENT ON COLUMN brief_arguments.hierarchy_path IS 'Display path (e.g., "III.A.1")';

-- Indexes
CREATE INDEX idx_brief_arguments_brief_id ON brief_arguments(brief_id);
CREATE INDEX idx_brief_arguments_case_id ON brief_arguments(case_id);
CREATE INDEX idx_brief_arguments_issue_id ON brief_arguments(issue_id);
CREATE INDEX idx_brief_arguments_parent ON brief_arguments(parent_argument_id);
CREATE INDEX idx_brief_arguments_hierarchy ON brief_arguments(brief_id, hierarchy_level, sort_order);

-- Updated timestamp trigger
CREATE TRIGGER trg_brief_arguments_updated BEFORE UPDATE ON brief_arguments
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- ============================================================================
-- TABLE 4: brief_citations (Citations with TOA priority)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_citations (
    brief_citation_id  BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    brief_id           BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    brief_argument_id  BIGINT REFERENCES brief_arguments(brief_argument_id) ON DELETE SET NULL,
    
    -- Citation details
    citation_text      CITEXT NOT NULL,
    citation_type      CITEXT,
    page_number        INTEGER,
    
    -- Table of Authorities flag (CRITICAL)
    from_toa           BOOLEAN DEFAULT FALSE,
    toa_page_refs      TEXT[],
    
    -- Links to other tables
    cited_case_id      BIGINT REFERENCES cases(case_id) ON DELETE SET NULL,
    statute_id         BIGINT REFERENCES statutes_dim(statute_id) ON DELETE SET NULL,
    
    -- Context
    context            TEXT,
    proposition        TEXT,
    
    created_at         TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE brief_citations IS 'Citations from briefs with Table of Authorities priority flagging';
COMMENT ON COLUMN brief_citations.from_toa IS 'TRUE if from Table of Authorities (high-confidence)';
COMMENT ON COLUMN brief_citations.toa_page_refs IS 'Page numbers where citation appears (from TOA)';

-- Indexes
CREATE INDEX idx_brief_citations_brief_id ON brief_citations(brief_id);
CREATE INDEX idx_brief_citations_argument_id ON brief_citations(brief_argument_id);
CREATE INDEX idx_brief_citations_case_id ON brief_citations(cited_case_id);
CREATE INDEX idx_brief_citations_statute_id ON brief_citations(statute_id);
CREATE INDEX idx_brief_citations_type ON brief_citations(citation_type);
CREATE INDEX idx_brief_citations_toa ON brief_citations(brief_id, from_toa) WHERE from_toa = TRUE;

-- ============================================================================
-- TABLE 5: brief_word_occurrence (Word-level indexing for RAG)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_word_occurrence (
    brief_id       BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    chunk_id       UUID NOT NULL REFERENCES brief_chunks(chunk_id) ON DELETE CASCADE,
    word_id        BIGINT NOT NULL REFERENCES word_dictionary(word_id) ON DELETE CASCADE,
    position       INTEGER NOT NULL,
    PRIMARY KEY (chunk_id, word_id, position)
);

COMMENT ON TABLE brief_word_occurrence IS 'Word-level indexing for briefs (reuses word_dictionary)';

-- Indexes
CREATE INDEX idx_brief_word_occurrence_word_id ON brief_word_occurrence(word_id);
CREATE INDEX idx_brief_word_occurrence_brief_id ON brief_word_occurrence(brief_id);
CREATE INDEX idx_brief_word_occurrence_chunk_id ON brief_word_occurrence(chunk_id);

-- ============================================================================
-- TABLE 6: brief_phrases (N-gram phrases from briefs)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_phrases (
    phrase_id      BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    brief_id       BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    phrase         CITEXT NOT NULL,
    frequency      INTEGER DEFAULT 1,
    phrase_length  INTEGER,
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE brief_phrases IS 'N-gram phrases extracted from briefs for phrase-based search';

-- Indexes
CREATE INDEX idx_brief_phrases_brief_id ON brief_phrases(brief_id);
CREATE INDEX idx_brief_phrases_phrase ON brief_phrases(phrase);
CREATE INDEX idx_brief_phrases_frequency ON brief_phrases(frequency DESC);

-- ============================================================================
-- TABLE 7: brief_sentences (Sentence-level indexing)
-- ============================================================================

CREATE TABLE IF NOT EXISTS brief_sentences (
    sentence_id    BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    brief_id       BIGINT NOT NULL REFERENCES briefs(brief_id) ON DELETE CASCADE,
    chunk_id       UUID REFERENCES brief_chunks(chunk_id) ON DELETE CASCADE,
    
    text           TEXT NOT NULL,
    position       INTEGER NOT NULL,
    word_count     INTEGER,
    embedding      VECTOR(1024),
    
    created_at     TIMESTAMP NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE brief_sentences IS 'Sentence-level indexing for briefs with embeddings';

-- Indexes
CREATE INDEX idx_brief_sentences_brief_id ON brief_sentences(brief_id);
CREATE INDEX idx_brief_sentences_chunk_id ON brief_sentences(chunk_id);

-- Vector similarity search
CREATE INDEX idx_brief_sentences_embedding ON brief_sentences 
    USING ivfflat (embedding vector_cosine_ops) 
    WITH (lists = 100);

-- ============================================================================
-- INDEX ON CASES TABLE FOR NORMALIZED MATCHING
-- ============================================================================

-- Create index on normalized case_file_id in cases table for fast lookups
CREATE INDEX IF NOT EXISTS idx_cases_normalized_file_id ON cases(
    normalize_case_file_id(case_file_id)
);

COMMENT ON INDEX idx_cases_normalized_file_id IS 'Fast lookups for normalized case_file_id matching';

-- ============================================================================
-- VALIDATION QUERIES
-- ============================================================================

-- Check if migration was successful
DO $$
DECLARE
    table_count INTEGER;
    index_count INTEGER;
BEGIN
    -- Count tables created
    SELECT COUNT(*) INTO table_count
    FROM information_schema.tables
    WHERE table_name IN (
        'briefs', 'brief_chunks', 'brief_arguments', 'brief_citations',
        'brief_word_occurrence', 'brief_phrases', 'brief_sentences'
    );
    
    -- Count indexes created
    SELECT COUNT(*) INTO index_count
    FROM pg_indexes
    WHERE tablename LIKE 'brief%';
    
    RAISE NOTICE 'âœ… Migration Complete!';
    RAISE NOTICE '   Tables created: %', table_count;
    RAISE NOTICE '   Indexes created: %', index_count;
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸ“Š Brief Schema Statistics:';
    RAISE NOTICE '   - 7 new tables for briefs';
    RAISE NOTICE '   - Multi-strategy case linking (folder + filename)';
    RAISE NOTICE '   - Brief chaining (conversation tracking)';
    RAISE NOTICE '   - Argument hierarchy (nested structure)';
    RAISE NOTICE '   - Table of Authorities priority';
    RAISE NOTICE '';
    RAISE NOTICE 'ðŸš€ Next Steps:';
    RAISE NOTICE '   1. Run batch_process_briefs.py to ingest briefs';
    RAISE NOTICE '   2. Check linking success: SELECT COUNT(*) FROM briefs WHERE case_id IS NOT NULL;';
    RAISE NOTICE '   3. Verify normalization: SELECT normalize_case_file_id(''69423-5'');';
END $$;
